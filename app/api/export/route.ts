import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/lib/supabase/server';
import type { Competitor, Claim, Tag } from '@/types/database';

const CLAIM_CATEGORIES = [
  'Custody model',
  'Rehypothecation or collateral reuse',
  'Margin calls or liquidation triggers',
  'Term length',
  'Repayment requirements',
  'Drawdown mechanics',
  'Loan currency',
  'Availability for Australian customers',
  'Eligibility or KYC constraints',
  'Insurance or guarantees',
  'Jurisdiction and legal posture',
  'Custody and security claims',
  'Product structure',
];

const PRIORITY_CATEGORIES = [
  'Custody model',
  'Rehypothecation or collateral reuse',
  'Margin calls or liquidation triggers',
  'Term length',
  'Repayment requirements',
  'Availability for Australian customers',
];

function formatDateISO(): string {
  return new Date().toISOString().split('T')[0];
}

function sortCompetitors(competitors: Competitor[]): Competitor[] {
  const tierOrder: Record<Tag, number> = { core: 1, adjacent: 2, contrast: 3 };
  
  return [...competitors].sort((a, b) => {
    if (a.is_baseline) return -1;
    if (b.is_baseline) return 1;
    const tierDiff = tierOrder[a.tag] - tierOrder[b.tag];
    if (tierDiff !== 0) return tierDiff;
    return a.name.localeCompare(b.name);
  });
}

function generateInvestorSummary(competitors: Competitor[], claims: Claim[]): string {
  const baseline = competitors.find(c => c.is_baseline);
  const date = formatDateISO();
  const baselineClaims = claims.filter(c => c.competitor_id === baseline?.id);
  
  let output = `COMPETITIVE POSITIONING SUMMARY\n`;
  output += `Escape Hatch vs. Bitcoin-Backed Lending Market\n`;
  output += `Generated: ${date}\n`;
  output += `${'═'.repeat(60)}\n\n`;
  
  output += `ESCAPE HATCH STRUCTURAL ADVANTAGES\n`;
  output += `${'─'.repeat(40)}\n`;
  
  for (const category of PRIORITY_CATEGORIES) {
    const claim = baselineClaims.find(c => c.category === category);
    if (claim) {
      output += `- ${claim.claim_text}\n`;
    }
  }
  
  // Group competitors by tier
  const tiers: Tag[] = ['core', 'adjacent', 'contrast'];
  const tierLabels: Record<Tag, string> = {
    core: 'CORE COMPETITORS',
    adjacent: 'ADJACENT COMPETITORS',
    contrast: 'CONTRAST COMPETITORS',
  };
  
  for (const tier of tiers) {
    const tierCompetitors = competitors.filter(c => c.tag === tier && !c.is_baseline);
    if (tierCompetitors.length === 0) continue;
    
    output += `\n${tierLabels[tier]}\n`;
    output += `${'─'.repeat(40)}\n`;
    
    for (const competitor of tierCompetitors) {
      output += `\n${competitor.name}\n`;
      const compClaims = claims.filter(c => c.competitor_id === competitor.id);
      for (const category of PRIORITY_CATEGORIES) {
        const claim = compClaims.find(c => c.category === category);
        if (claim) {
          const verifiedMark = claim.verified ? '✓ ' : '';
          output += `  • ${category}: ${verifiedMark}${claim.claim_text}\n`;
        } else {
          output += `  • ${category}: No data\n`;
        }
      }
    }
  }
  
  output += `\n${'═'.repeat(60)}\n`;
  output += `Generated by Escape Hatch Competitor Intelligence\n`;
  
  return output;
}

function generateFullText(competitors: Competitor[], claims: Claim[]): string {
  const date = formatDateISO();
  
  let output = `# Competitor Comparison Matrix\n\n`;
  output += `**Generated:** ${date}\n\n`;
  output += `## Legend\n`;
  output += `- ■ Escape Hatch baseline\n`;
  output += `- △ Priority comparison category\n`;
  output += `- ✓ Verified claim\n\n`;
  output += `---\n\n`;
  
  for (const competitor of sortCompetitors(competitors)) {
    const label = competitor.is_baseline ? 'Baseline' : competitor.tag;
    const compClaims = claims.filter(c => c.competitor_id === competitor.id);
    const verifiedCount = compClaims.filter(c => c.verified).length;
    
    output += `## ${competitor.name} (${label})\n`;
    output += `*${verifiedCount}/${compClaims.length} verified claims*\n\n`;
    
    for (const category of CLAIM_CATEGORIES) {
      const isPriority = PRIORITY_CATEGORIES.includes(category as typeof PRIORITY_CATEGORIES[number]);
      const priorityMark = isPriority ? ' △' : '';
      output += `### ${category}${priorityMark}\n`;
      
      const claim = compClaims.find(c => c.category === category);
      if (claim) {
        const verifiedMark = claim.verified ? '✓ ' : '';
        output += `${verifiedMark}${claim.claim_text}\n\n`;
      } else {
        output += `- No data\n\n`;
      }
    }
    
    output += `---\n\n`;
  }
  
  return output;
}

function generateCSV(competitors: Competitor[], claims: Claim[]): string {
  const headers = [
    'competitor_name',
    'competitor_tag',
    'is_baseline',
    'category',
    'is_priority',
    'claim_text',
    'verified',
    'status',
  ];
  
  const rows: string[][] = [headers];
  
  for (const competitor of sortCompetitors(competitors)) {
    for (const category of CLAIM_CATEGORIES) {
      const claim = claims.find(
        c => c.competitor_id === competitor.id && c.category === category
      );
      const isPriority = PRIORITY_CATEGORIES.includes(category as typeof PRIORITY_CATEGORIES[number]);
      
      rows.push([
        competitor.name,
        competitor.tag,
        String(competitor.is_baseline),
        category,
        String(isPriority),
        claim?.claim_text || '',
        String(claim?.verified || false),
        claim?.status || '',
      ]);
    }
  }
  
  return rows.map(row => 
    row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',')
  ).join('\n');
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const format = searchParams.get('format') || 'investor';
    const tiersParam = searchParams.get('tiers');
    
    const supabase = createServerClient();
    
    // Fetch competitors
    let competitorsQuery = supabase.from('competitors').select('*');
    
    if (tiersParam) {
      const tiers = tiersParam.split(',') as Tag[];
      competitorsQuery = supabase
        .from('competitors')
        .select('*')
        .or(`is_baseline.eq.true,tag.in.(${tiers.join(',')})`);
    }
    
    const { data: competitors, error: compError } = await competitorsQuery;
    if (compError) throw new Error(compError.message);
    
    // Fetch claims
    const competitorIds = (competitors || []).map(c => c.id);
    const { data: claims, error: claimsError } = await supabase
      .from('claims')
      .select('*')
      .in('competitor_id', competitorIds);
    
    if (claimsError) throw new Error(claimsError.message);
    
    let content: string;
    let filename: string;
    let contentType: string;
    
    const date = formatDateISO();
    
    switch (format) {
      case 'investor':
        content = generateInvestorSummary(competitors || [], claims || []);
        filename = `escape-hatch-investor-summary-${date}.txt`;
        contentType = 'text/plain';
        break;
      
      case 'fulltext':
        content = generateFullText(competitors || [], claims || []);
        filename = `escape-hatch-comparison-${date}.md`;
        contentType = 'text/markdown';
        break;
      
      case 'csv':
        content = generateCSV(competitors || [], claims || []);
        filename = `escape-hatch-comparison-${date}.csv`;
        contentType = 'text/csv';
        break;
      
      default:
        return NextResponse.json(
          { error: 'Invalid format. Use: investor, fulltext, csv' },
          { status: 400 }
        );
    }
    
    // Return with appropriate headers for download
    const response = new NextResponse(content);
    response.headers.set('Content-Type', contentType);
    response.headers.set('Content-Disposition', `attachment; filename="${filename}"`);
    
    return response;
  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json(
      { error: 'Failed to generate export' },
      { status: 500 }
    );
  }
}
